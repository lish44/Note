
--------

操作系统保持genz进程所需的所有状态信息 i.e. 这种状态就是上下文 (e.g. pc)

每个进程都有两个栈 一个 **用户栈** 存在用户空间， 一个 **内核栈** 存在内核空间，当因为中断或系统调用trap到内核态时，
**先把当前用户态执行的地址保存在内核栈中，然后设置 cup pc的地址为内核栈地址** ，此时就进入了内核态。进程的内核栈每次进入总是空的
因为每次进入会保存当前用户态的相关信息，一旦返回就会清空
(无法验证是否正确 摘要自[博文](https://open.toutiao.com/open/mobile_detail/vivo_custom?utm_source=vivoliulanqi&utm_medium=webview&utm_campaign=open&label=related_news&item_id=6970209169207017996&gy=d5ad82964139bbc859cadc07f4df7&req_id=2021081109573701021214213735574E39&fr=normal&isRelated=1&isNews=1&vivoRcdMark=1&from_gid=6968719543107732000&channel_id=88805669586&groupId=6970209169207017996https://open.toutiao.com/open/mobile_detail/vivo_custom?utm_source=vivoliulanqi&utm_medium=webview&utm_campaign=open&label=related_news&item_id=6970209169207017996&gy=d5ad82964139bbc859cadc07f4df7&req_id=2021081109573701021214213735574E39&fr=normal&isRelated=1&isNews=1&vivoRcdMark=1&from_gid=6968719543107732000&channel_id=88805669586&groupId=6970209169207017996)) 



<font color=#bf616a>其实就是一段执行流程，本质就是堆栈，当一段程序在执行，能代表它的是他的过去和现在。"过去"在线程堆栈中，"现在"则是CPU的所有寄存器，如果我们要挂起一个线程，我们把寄存器也保存到堆栈中，我们就具有它的所有状态，可以随时恢复它。这是线程。</font>
[原文](https://www.zhihu.com/question/40147261) 

question:线程切换时上下文保存在当前线程栈中还是PCB中还是TCB中？ans:看具体os实现

当进程切换到内核态时，**会先找到该 <font color=#a3be8c>用户态线程</font> 对应的 <font color=#bf616a>内核线程</font>** 执行的内核代码会使用当前进程内的内核栈

内核态操作都是os内代码

早期trap通过软中断触发 i.e. 就是通过指令模拟中断

question:状态切换时上下文保存在哪里？ans:一部分cpu寄存器值通过硬件保存，一部分通用寄存器的值和当前线程地址被保存进程内核栈中

以上综合 大概就是 切换时context保存在了进程区域内的内核栈中，然后进程的特权等级提升为ring0，pc跑到内核去执行对应 kernel 代码，然后运行时的一些os函数（此时是ring0等级）都会压在内核栈中，
执行完对应指令后，pop内核栈（其实就是刚刚进入保存的context）内容给CPU寄存器，此时就完成了内核态到用户态的恢复，pc又跑到用户态下刚刚中断的地方继续执行。

进程中内核虚拟空间在栈顶，包括（内核代码，数据，堆，栈）i.e.545页

PCB 进程控制块 

TCB 线程控制块(thread control block) 只负责这条流程(线程)的信息，包括PC程序计数器，SP堆栈，State状态，和寄存器

### 内核空间

**内核空间由所有进程的地址空间共享**

1. 内核代码 数据以及占用的物理内存。保存的是同一份（保存的地址？）
2. 进程相关信息（如页表、内核栈、进程控制信息等），这部分对每个进程来说都是不同的

interview：
进程官方定义：是算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早起计算机中是执行的实体，当代是线程的集合容器

进程可以描述程序的执行过程，当被os加载到memory中时，才有了生命，简单说就是mmu映射的一段虚拟地址空间，我们写的代码逻辑集就跑在其中。它分为了内核空间和用户空间，内核空间中保存了进程控制信息、页目录、内核栈（独享）等。

线程就是进程中的执行体

--------


[ring 0被叫做内核态，完全在操作系统内核中运行?](https://segmentfault.com/a/1190000039774784) 
Kernel 运行在超级权限模式（Supervisor Mode）下，所以拥有很高的权限，按照权限管理的原则，多数应用程序应该运行在最小权限下

内核态 其实就是 **cpu** 进程执行的一种特权级状态（ring0） i.e. Linux下一共有4级 l0 最高 ring3 最低

用户态 其实就是进程执行当前用户代码 (ring3)

用户级线程

- 所有工作由应用程序完成，内核意识不到线程存在，应用程序可通过线程库设计成多线程线程。
- 用户级线程仅在用户空间中（进程空间的线程堆栈中？）
- 创建、撤销、线程之间的同步与通信功能，都无须利用系统调用来实现

线程模型

四种模型

1:1 (内核级线程模型)

一个用户级线程bind一个内核级线程 可以充分利用多核进行 **并行** 执行

n:1 (用户级线程模型)

trait:
- 同一时刻一个kernel只能运行一个内核级线程，一个内核级线程对应一个进程，
并且由 **库调度器** 指定当前进程内其中一个线程与内核级线程对应执行，
这里真正被CPU执行是内核级线程

pros:
- 极大减少内核态线程创建成本

cons:
- 用户级线程不可并行，因为os无法感知有多个用户级线程存在

多个用户级线程bind一个内核级线程 在os

n:m

n:m + 1:1

[模型参考原文](https://blog.csdn.net/gatieme/article/details/51892437)
