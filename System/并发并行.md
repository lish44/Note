1.9.2

### 概念

**并发 concurrency**

<font color=#bf616a>宏观上是同时执行 微观是串行</font>

**并行 parallelism**

<font color=#bf616a>都是同时执行 具体实际的执行方式看具体os的调度实现</font>

### 并发编程特性

要实现临界资源（共享变量）的可见性，至少要保证两点：
1:线程修改了共享变量的值过后，要能够及时的从工作内存刷新回到主内存中
2:其它线程要能够及时的从主内存中，把最新的数据更新到自己的工作内存中“

#### 原子性

> 原子性：就是把一个或多个操作看成是一个原子操作，在CPU执行过程中，不会被中断，这样的特性就称为原子性。

e.g. 有个全局变量num，此时线程a从内存读出来进行++，此时发现线程切换b，线程b也有同样操作，然后写回内存num的值是1，然后切换回a，a也写回内存此时num的值也是1。 此时就说没有满足可见性

#### 可见性

> 一个线程对临界资源（共享变量）的修改，另一个线程能够立即看到

e.g. 有个全局变量num，此时线程a从内存读出来进行++，线程b也有同样操作，但是b读取的不是a++后的，此时是同时并行执行的，此时就说a的操作对于b不可见，


#### 有序性

> 编译器优化，编译后的指令顺序和写的代码顺序不一致，单线程无所谓因为总是能保证结果确定，多线程不保证因为切换

e.g. 单例双重校验，线程a创建实例ins，1.申请内存 2.对象写入内存 3.返回地址，此时发送指令重排132，对于2和3顺序无所谓，因为1过后就知道了地址，但在多线程环境下此时发生线程切换b，b进来是发现ins有地址（但此时地址指向的堆没有数据），所以执行后会发生异常

### 重排序

> 重排序：编译器或处理器为了优化程序的性能，对指令执行的顺序进行重新排列
的一种手段

关系: 源代码 -> 编译器优化 -> 指令级并行 -> 内存系统 -> 最终执行指令

#### 1.编译器优化的重排序

>编译器在不改变程序在单线程环境下运行的语义前提下，可以重新安排语句的执行顺序 目的：尽可能减少寄存器的读取、存储次数，复用寄存器存储的数据

e.g. 1. a = 99 2. b = 88 3. c = a，这时可能优化成132 

#### 2.指令级并行的重排序

> 处理器将多条指令并行执行，如果不存在数据依赖，处理器可以改变语句对应的指令的执行顺序

e.g. 1. int a = 10 2.int b = 20，12顺序不影响后续依赖

#### 3.内存系统的的重排序


#### 数据依赖

>如果两个操作访问同一个共享变量，而且，这两个操作里面有一个为写操作，那么这两个操作之间就存在数据依赖性

数据依赖的分类：

- 读后写：读一个变量过后，再写一个变量

	a = b;

	b = 1;

- 写后写：写一个变量过后，再写一个变量

	a = 5;

	a = 6;

- 写后读：写一个变量过后，再读这个变量

	a = 1;

	b = a;

以上这些有依赖性的就不能被重排

#### as-if-serial语义

> 不管有没有重排序，也不关心如何进行的重排序，单线程环境下，程序的执行结果不会被改变

--------

### happens-before

[go](../Go/channel.md) 

1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果，将对第二个操作可见。（保障可见性)而且第一个操作的执行顺序排在第二个操作之前。（MM对程序员做出的一个逻辑保障，并不是代码指令真正的执行保障)

2. 即使两个操作之间存在happens-before关系，并不意味着Java平台的实现必须要按照happens-.before关系指定的顺序来执行

[link](https://www.bilibili.com/video/BV1GF411p7As/?spm_id_from=333.788&vd_source=b2209c516e49ddd3ec341587f8c30826) 
